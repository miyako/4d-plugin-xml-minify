/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-XML-Minify.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : XML Minify
 #	author : miyako
 #	2020/01/08
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-XML-Minify.h"

#pragma mark -

void OnStartup()
{
    xmlInitParser();
    
    /*
     xmlMemSetup must be the very first call to libxml2 then call
         xmlInitParser(). Don't call xmlInitMemory by yourself, xmlInitParser
         will do it.
         https://mail.gnome.org/archives/xml/2007-August/msg00037.html
     */
}

void OnExit()
{
    xmlCleanupParser();
    
    /*
     WARNING: if your application is multithreaded or has plugin support calling this may crash the application if another thread or a plugin is still using libxml2. It's sometimes very hard to guess if libxml2 is in use in the application, some libraries or plugins may use it without notice. In case of doubt abstain from calling this function or do it just before calling exit() to avoid leak reports from valgrind !
         http://xmlsoft.org/html/libxml-parser.html#xmlCleanupParser
     */
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
#ifdef _WIN64
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)OnStartup, NULL);
#else
                OnStartup();
#endif // _WIN64
                break;
                
            case kDeinitPlugin :
#ifdef _WIN64
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)OnExit, NULL);
#else
                OnExit();
#endif // _WIN64
                
                break;
			// --- XML Minify
            
			case 1 :
				XML_Minify(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void XML_Minify(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT xml;
    C_TEXT returnValue;
    
    xml.fromParamAtIndex(pParams, 1);
    
    CUTF8String u8;
    xml.copyUTF8String(&u8);
    
    xmlKeepBlanksDefault(0);
    
    xmlDocPtr xmlDoc = xmlParseMemory((const char *)u8.c_str(), (int)u8.size());
    
    if(xmlDoc) {
       
        xmlNodePtr xmlNodeRoot = xmlDocGetRootElement(xmlDoc);
        
        if(xmlNodeRoot) {
            xmlBufferPtr buf = xmlBufferCreate();
            
            if(buf) {
                                
                int len = xmlNodeDump(buf,
                                      xmlDoc,
                                      xmlNodeRoot,
                                      0,
                                      0);
                
                if (len > 0) {
                    returnValue.setUTF8String((const uint8_t *)xmlBufferContent(buf), len);
                }
                xmlBufferFree(buf);
            }
            
        }
        xmlFreeDoc(xmlDoc);
    }
    returnValue.setReturn(pResult);
}
